// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: properman.proto

package properman

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GreeterClient interface {
	// Sends a greeting
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
	// Sends another greeting
	SayHelloAgain(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/Greeter/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterClient) SayHelloAgain(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/Greeter/SayHelloAgain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServer is the server API for Greeter service.
// All implementations must embed UnimplementedGreeterServer
// for forward compatibility
type GreeterServer interface {
	// Sends a greeting
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
	// Sends another greeting
	SayHelloAgain(context.Context, *HelloRequest) (*HelloReply, error)
	mustEmbedUnimplementedGreeterServer()
}

// UnimplementedGreeterServer must be embedded to have forward compatible implementations.
type UnimplementedGreeterServer struct {
}

func (UnimplementedGreeterServer) SayHello(context.Context, *HelloRequest) (*HelloReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}
func (UnimplementedGreeterServer) SayHelloAgain(context.Context, *HelloRequest) (*HelloReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHelloAgain not implemented")
}
func (UnimplementedGreeterServer) mustEmbedUnimplementedGreeterServer() {}

// UnsafeGreeterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServer will
// result in compilation errors.
type UnsafeGreeterServer interface {
	mustEmbedUnimplementedGreeterServer()
}

func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) {
	s.RegisterService(&Greeter_ServiceDesc, srv)
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Greeter/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Greeter_SayHelloAgain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHelloAgain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Greeter/SayHelloAgain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHelloAgain(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Greeter_ServiceDesc is the grpc.ServiceDesc for Greeter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Greeter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_Handler,
		},
		{
			MethodName: "SayHelloAgain",
			Handler:    _Greeter_SayHelloAgain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// LandlordServiceClient is the client API for LandlordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LandlordServiceClient interface {
	CreateProperty(ctx context.Context, in *CreatePropertyRequest, opts ...grpc.CallOption) (*CreatePropertyResponse, error)
	CreateProperties(ctx context.Context, in *CreatePropertiesRequest, opts ...grpc.CallOption) (*CreatePropertiesResponse, error)
	GetProperties(ctx context.Context, in *GetPropertiesRequest, opts ...grpc.CallOption) (*PropertiesResponse, error)
	DeleteProperty(ctx context.Context, in *DeletePropertyRequest, opts ...grpc.CallOption) (*DeletePropertyResponse, error)
	DeleteProperties(ctx context.Context, in *DeletePropertiesRequest, opts ...grpc.CallOption) (*DeletePropertiesResponse, error)
	CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error)
	CreateTenants(ctx context.Context, in *CreateTenantsRequest, opts ...grpc.CallOption) (*CreateTenantsResponse, error)
	GetTenants(ctx context.Context, in *GetTenantsRequest, opts ...grpc.CallOption) (*TenantsResponse, error)
	DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*DeleteTenantResponse, error)
}

type landlordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLandlordServiceClient(cc grpc.ClientConnInterface) LandlordServiceClient {
	return &landlordServiceClient{cc}
}

func (c *landlordServiceClient) CreateProperty(ctx context.Context, in *CreatePropertyRequest, opts ...grpc.CallOption) (*CreatePropertyResponse, error) {
	out := new(CreatePropertyResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/CreateProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) CreateProperties(ctx context.Context, in *CreatePropertiesRequest, opts ...grpc.CallOption) (*CreatePropertiesResponse, error) {
	out := new(CreatePropertiesResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/CreateProperties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) GetProperties(ctx context.Context, in *GetPropertiesRequest, opts ...grpc.CallOption) (*PropertiesResponse, error) {
	out := new(PropertiesResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/GetProperties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) DeleteProperty(ctx context.Context, in *DeletePropertyRequest, opts ...grpc.CallOption) (*DeletePropertyResponse, error) {
	out := new(DeletePropertyResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/DeleteProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) DeleteProperties(ctx context.Context, in *DeletePropertiesRequest, opts ...grpc.CallOption) (*DeletePropertiesResponse, error) {
	out := new(DeletePropertiesResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/DeleteProperties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error) {
	out := new(CreateTenantResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/CreateTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) CreateTenants(ctx context.Context, in *CreateTenantsRequest, opts ...grpc.CallOption) (*CreateTenantsResponse, error) {
	out := new(CreateTenantsResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/CreateTenants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) GetTenants(ctx context.Context, in *GetTenantsRequest, opts ...grpc.CallOption) (*TenantsResponse, error) {
	out := new(TenantsResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/GetTenants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *landlordServiceClient) DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*DeleteTenantResponse, error) {
	out := new(DeleteTenantResponse)
	err := c.cc.Invoke(ctx, "/LandlordService/DeleteTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LandlordServiceServer is the server API for LandlordService service.
// All implementations must embed UnimplementedLandlordServiceServer
// for forward compatibility
type LandlordServiceServer interface {
	CreateProperty(context.Context, *CreatePropertyRequest) (*CreatePropertyResponse, error)
	CreateProperties(context.Context, *CreatePropertiesRequest) (*CreatePropertiesResponse, error)
	GetProperties(context.Context, *GetPropertiesRequest) (*PropertiesResponse, error)
	DeleteProperty(context.Context, *DeletePropertyRequest) (*DeletePropertyResponse, error)
	DeleteProperties(context.Context, *DeletePropertiesRequest) (*DeletePropertiesResponse, error)
	CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error)
	CreateTenants(context.Context, *CreateTenantsRequest) (*CreateTenantsResponse, error)
	GetTenants(context.Context, *GetTenantsRequest) (*TenantsResponse, error)
	DeleteTenant(context.Context, *DeleteTenantRequest) (*DeleteTenantResponse, error)
	mustEmbedUnimplementedLandlordServiceServer()
}

// UnimplementedLandlordServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLandlordServiceServer struct {
}

func (UnimplementedLandlordServiceServer) CreateProperty(context.Context, *CreatePropertyRequest) (*CreatePropertyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProperty not implemented")
}
func (UnimplementedLandlordServiceServer) CreateProperties(context.Context, *CreatePropertiesRequest) (*CreatePropertiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProperties not implemented")
}
func (UnimplementedLandlordServiceServer) GetProperties(context.Context, *GetPropertiesRequest) (*PropertiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProperties not implemented")
}
func (UnimplementedLandlordServiceServer) DeleteProperty(context.Context, *DeletePropertyRequest) (*DeletePropertyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProperty not implemented")
}
func (UnimplementedLandlordServiceServer) DeleteProperties(context.Context, *DeletePropertiesRequest) (*DeletePropertiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProperties not implemented")
}
func (UnimplementedLandlordServiceServer) CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTenant not implemented")
}
func (UnimplementedLandlordServiceServer) CreateTenants(context.Context, *CreateTenantsRequest) (*CreateTenantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTenants not implemented")
}
func (UnimplementedLandlordServiceServer) GetTenants(context.Context, *GetTenantsRequest) (*TenantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenants not implemented")
}
func (UnimplementedLandlordServiceServer) DeleteTenant(context.Context, *DeleteTenantRequest) (*DeleteTenantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTenant not implemented")
}
func (UnimplementedLandlordServiceServer) mustEmbedUnimplementedLandlordServiceServer() {}

// UnsafeLandlordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LandlordServiceServer will
// result in compilation errors.
type UnsafeLandlordServiceServer interface {
	mustEmbedUnimplementedLandlordServiceServer()
}

func RegisterLandlordServiceServer(s grpc.ServiceRegistrar, srv LandlordServiceServer) {
	s.RegisterService(&LandlordService_ServiceDesc, srv)
}

func _LandlordService_CreateProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePropertyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).CreateProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/CreateProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).CreateProperty(ctx, req.(*CreatePropertyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_CreateProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).CreateProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/CreateProperties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).CreateProperties(ctx, req.(*CreatePropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_GetProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).GetProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/GetProperties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).GetProperties(ctx, req.(*GetPropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_DeleteProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePropertyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).DeleteProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/DeleteProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).DeleteProperty(ctx, req.(*DeletePropertyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_DeleteProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).DeleteProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/DeleteProperties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).DeleteProperties(ctx, req.(*DeletePropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_CreateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).CreateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/CreateTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).CreateTenant(ctx, req.(*CreateTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_CreateTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).CreateTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/CreateTenants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).CreateTenants(ctx, req.(*CreateTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_GetTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).GetTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/GetTenants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).GetTenants(ctx, req.(*GetTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LandlordService_DeleteTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LandlordServiceServer).DeleteTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LandlordService/DeleteTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LandlordServiceServer).DeleteTenant(ctx, req.(*DeleteTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LandlordService_ServiceDesc is the grpc.ServiceDesc for LandlordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LandlordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "LandlordService",
	HandlerType: (*LandlordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProperty",
			Handler:    _LandlordService_CreateProperty_Handler,
		},
		{
			MethodName: "CreateProperties",
			Handler:    _LandlordService_CreateProperties_Handler,
		},
		{
			MethodName: "GetProperties",
			Handler:    _LandlordService_GetProperties_Handler,
		},
		{
			MethodName: "DeleteProperty",
			Handler:    _LandlordService_DeleteProperty_Handler,
		},
		{
			MethodName: "DeleteProperties",
			Handler:    _LandlordService_DeleteProperties_Handler,
		},
		{
			MethodName: "CreateTenant",
			Handler:    _LandlordService_CreateTenant_Handler,
		},
		{
			MethodName: "CreateTenants",
			Handler:    _LandlordService_CreateTenants_Handler,
		},
		{
			MethodName: "GetTenants",
			Handler:    _LandlordService_GetTenants_Handler,
		},
		{
			MethodName: "DeleteTenant",
			Handler:    _LandlordService_DeleteTenant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// TenantServiceClient is the client API for TenantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantServiceClient interface {
	FindProperties(ctx context.Context, in *PropertiesSearchRequest, opts ...grpc.CallOption) (*PropertiesResponse, error)
	RentAProperty(ctx context.Context, in *RentAPropertyRequest, opts ...grpc.CallOption) (*RentAPropertyResponse, error)
	MoveOut(ctx context.Context, in *MoveOutRequest, opts ...grpc.CallOption) (*MoveOutResponse, error)
	GetPastRentals(ctx context.Context, in *GetPastRentalsRequest, opts ...grpc.CallOption) (*PropertiesResponse, error)
}

type tenantServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantServiceClient(cc grpc.ClientConnInterface) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) FindProperties(ctx context.Context, in *PropertiesSearchRequest, opts ...grpc.CallOption) (*PropertiesResponse, error) {
	out := new(PropertiesResponse)
	err := c.cc.Invoke(ctx, "/TenantService/FindProperties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) RentAProperty(ctx context.Context, in *RentAPropertyRequest, opts ...grpc.CallOption) (*RentAPropertyResponse, error) {
	out := new(RentAPropertyResponse)
	err := c.cc.Invoke(ctx, "/TenantService/RentAProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) MoveOut(ctx context.Context, in *MoveOutRequest, opts ...grpc.CallOption) (*MoveOutResponse, error) {
	out := new(MoveOutResponse)
	err := c.cc.Invoke(ctx, "/TenantService/MoveOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetPastRentals(ctx context.Context, in *GetPastRentalsRequest, opts ...grpc.CallOption) (*PropertiesResponse, error) {
	out := new(PropertiesResponse)
	err := c.cc.Invoke(ctx, "/TenantService/GetPastRentals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantServiceServer is the server API for TenantService service.
// All implementations must embed UnimplementedTenantServiceServer
// for forward compatibility
type TenantServiceServer interface {
	FindProperties(context.Context, *PropertiesSearchRequest) (*PropertiesResponse, error)
	RentAProperty(context.Context, *RentAPropertyRequest) (*RentAPropertyResponse, error)
	MoveOut(context.Context, *MoveOutRequest) (*MoveOutResponse, error)
	GetPastRentals(context.Context, *GetPastRentalsRequest) (*PropertiesResponse, error)
	mustEmbedUnimplementedTenantServiceServer()
}

// UnimplementedTenantServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTenantServiceServer struct {
}

func (UnimplementedTenantServiceServer) FindProperties(context.Context, *PropertiesSearchRequest) (*PropertiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindProperties not implemented")
}
func (UnimplementedTenantServiceServer) RentAProperty(context.Context, *RentAPropertyRequest) (*RentAPropertyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RentAProperty not implemented")
}
func (UnimplementedTenantServiceServer) MoveOut(context.Context, *MoveOutRequest) (*MoveOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveOut not implemented")
}
func (UnimplementedTenantServiceServer) GetPastRentals(context.Context, *GetPastRentalsRequest) (*PropertiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPastRentals not implemented")
}
func (UnimplementedTenantServiceServer) mustEmbedUnimplementedTenantServiceServer() {}

// UnsafeTenantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServiceServer will
// result in compilation errors.
type UnsafeTenantServiceServer interface {
	mustEmbedUnimplementedTenantServiceServer()
}

func RegisterTenantServiceServer(s grpc.ServiceRegistrar, srv TenantServiceServer) {
	s.RegisterService(&TenantService_ServiceDesc, srv)
}

func _TenantService_FindProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropertiesSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).FindProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/FindProperties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).FindProperties(ctx, req.(*PropertiesSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_RentAProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RentAPropertyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).RentAProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/RentAProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).RentAProperty(ctx, req.(*RentAPropertyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_MoveOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).MoveOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/MoveOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).MoveOut(ctx, req.(*MoveOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetPastRentals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPastRentalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetPastRentals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/GetPastRentals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetPastRentals(ctx, req.(*GetPastRentalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantService_ServiceDesc is the grpc.ServiceDesc for TenantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindProperties",
			Handler:    _TenantService_FindProperties_Handler,
		},
		{
			MethodName: "RentAProperty",
			Handler:    _TenantService_RentAProperty_Handler,
		},
		{
			MethodName: "MoveOut",
			Handler:    _TenantService_MoveOut_Handler,
		},
		{
			MethodName: "GetPastRentals",
			Handler:    _TenantService_GetPastRentals_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// PaymentsServiceClient is the client API for PaymentsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentsServiceClient interface {
	GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error)
	ClearBills(ctx context.Context, in *ClearBillsRequest, opts ...grpc.CallOption) (*ClearBillsResponse, error)
	CreatePaymentGateway(ctx context.Context, in *CreatePaymentGatewayRequest, opts ...grpc.CallOption) (*CreatePaymentGatewayResponse, error)
	UpdatePaymentGateway(ctx context.Context, in *UpdatePaymentGatewayRequest, opts ...grpc.CallOption) (*UpdatePaymentGatewayResponse, error)
}

type paymentsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentsServiceClient(cc grpc.ClientConnInterface) PaymentsServiceClient {
	return &paymentsServiceClient{cc}
}

func (c *paymentsServiceClient) GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error) {
	out := new(GetSupportedCurrenciesResponse)
	err := c.cc.Invoke(ctx, "/PaymentsService/GetSupportedCurrencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentsServiceClient) ClearBills(ctx context.Context, in *ClearBillsRequest, opts ...grpc.CallOption) (*ClearBillsResponse, error) {
	out := new(ClearBillsResponse)
	err := c.cc.Invoke(ctx, "/PaymentsService/ClearBills", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentsServiceClient) CreatePaymentGateway(ctx context.Context, in *CreatePaymentGatewayRequest, opts ...grpc.CallOption) (*CreatePaymentGatewayResponse, error) {
	out := new(CreatePaymentGatewayResponse)
	err := c.cc.Invoke(ctx, "/PaymentsService/CreatePaymentGateway", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentsServiceClient) UpdatePaymentGateway(ctx context.Context, in *UpdatePaymentGatewayRequest, opts ...grpc.CallOption) (*UpdatePaymentGatewayResponse, error) {
	out := new(UpdatePaymentGatewayResponse)
	err := c.cc.Invoke(ctx, "/PaymentsService/UpdatePaymentGateway", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentsServiceServer is the server API for PaymentsService service.
// All implementations must embed UnimplementedPaymentsServiceServer
// for forward compatibility
type PaymentsServiceServer interface {
	GetSupportedCurrencies(context.Context, *Empty) (*GetSupportedCurrenciesResponse, error)
	ClearBills(context.Context, *ClearBillsRequest) (*ClearBillsResponse, error)
	CreatePaymentGateway(context.Context, *CreatePaymentGatewayRequest) (*CreatePaymentGatewayResponse, error)
	UpdatePaymentGateway(context.Context, *UpdatePaymentGatewayRequest) (*UpdatePaymentGatewayResponse, error)
	mustEmbedUnimplementedPaymentsServiceServer()
}

// UnimplementedPaymentsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentsServiceServer struct {
}

func (UnimplementedPaymentsServiceServer) GetSupportedCurrencies(context.Context, *Empty) (*GetSupportedCurrenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupportedCurrencies not implemented")
}
func (UnimplementedPaymentsServiceServer) ClearBills(context.Context, *ClearBillsRequest) (*ClearBillsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearBills not implemented")
}
func (UnimplementedPaymentsServiceServer) CreatePaymentGateway(context.Context, *CreatePaymentGatewayRequest) (*CreatePaymentGatewayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentGateway not implemented")
}
func (UnimplementedPaymentsServiceServer) UpdatePaymentGateway(context.Context, *UpdatePaymentGatewayRequest) (*UpdatePaymentGatewayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePaymentGateway not implemented")
}
func (UnimplementedPaymentsServiceServer) mustEmbedUnimplementedPaymentsServiceServer() {}

// UnsafePaymentsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentsServiceServer will
// result in compilation errors.
type UnsafePaymentsServiceServer interface {
	mustEmbedUnimplementedPaymentsServiceServer()
}

func RegisterPaymentsServiceServer(s grpc.ServiceRegistrar, srv PaymentsServiceServer) {
	s.RegisterService(&PaymentsService_ServiceDesc, srv)
}

func _PaymentsService_GetSupportedCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentsServiceServer).GetSupportedCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PaymentsService/GetSupportedCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentsServiceServer).GetSupportedCurrencies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentsService_ClearBills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearBillsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentsServiceServer).ClearBills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PaymentsService/ClearBills",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentsServiceServer).ClearBills(ctx, req.(*ClearBillsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentsService_CreatePaymentGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentsServiceServer).CreatePaymentGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PaymentsService/CreatePaymentGateway",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentsServiceServer).CreatePaymentGateway(ctx, req.(*CreatePaymentGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentsService_UpdatePaymentGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePaymentGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentsServiceServer).UpdatePaymentGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PaymentsService/UpdatePaymentGateway",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentsServiceServer).UpdatePaymentGateway(ctx, req.(*UpdatePaymentGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentsService_ServiceDesc is the grpc.ServiceDesc for PaymentsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PaymentsService",
	HandlerType: (*PaymentsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSupportedCurrencies",
			Handler:    _PaymentsService_GetSupportedCurrencies_Handler,
		},
		{
			MethodName: "ClearBills",
			Handler:    _PaymentsService_ClearBills_Handler,
		},
		{
			MethodName: "CreatePaymentGateway",
			Handler:    _PaymentsService_CreatePaymentGateway_Handler,
		},
		{
			MethodName: "UpdatePaymentGateway",
			Handler:    _PaymentsService_UpdatePaymentGateway_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// PropertyAccountingServiceClient is the client API for PropertyAccountingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PropertyAccountingServiceClient interface {
	TrackPropertyRentalIncome(ctx context.Context, in *TrackPropertyRentalIncomeRequest, opts ...grpc.CallOption) (*TrackPropertyRentalIncomeResponse, error)
	TrackPropertiesRentalIncome(ctx context.Context, in *TrackPropertiesRentalIncomeRequest, opts ...grpc.CallOption) (*TrackPropertiesRentalIncomeResponse, error)
	TrackPropertyExpenses(ctx context.Context, in *TrackPropertyExpensesRequest, opts ...grpc.CallOption) (*TrackPropertyExpensesResponse, error)
	GeneratePropertyFinancialStatements(ctx context.Context, in *GeneratePropertyFinancialStatementsRequest, opts ...grpc.CallOption) (*GeneratePropertyFinancialStatementsResponse, error)
	GetPropertyFinancialReport(ctx context.Context, in *GetPropertyFinancialReportRequest, opts ...grpc.CallOption) (*GetPropertyFinancialReportResponse, error)
}

type propertyAccountingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPropertyAccountingServiceClient(cc grpc.ClientConnInterface) PropertyAccountingServiceClient {
	return &propertyAccountingServiceClient{cc}
}

func (c *propertyAccountingServiceClient) TrackPropertyRentalIncome(ctx context.Context, in *TrackPropertyRentalIncomeRequest, opts ...grpc.CallOption) (*TrackPropertyRentalIncomeResponse, error) {
	out := new(TrackPropertyRentalIncomeResponse)
	err := c.cc.Invoke(ctx, "/PropertyAccountingService/TrackPropertyRentalIncome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *propertyAccountingServiceClient) TrackPropertiesRentalIncome(ctx context.Context, in *TrackPropertiesRentalIncomeRequest, opts ...grpc.CallOption) (*TrackPropertiesRentalIncomeResponse, error) {
	out := new(TrackPropertiesRentalIncomeResponse)
	err := c.cc.Invoke(ctx, "/PropertyAccountingService/TrackPropertiesRentalIncome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *propertyAccountingServiceClient) TrackPropertyExpenses(ctx context.Context, in *TrackPropertyExpensesRequest, opts ...grpc.CallOption) (*TrackPropertyExpensesResponse, error) {
	out := new(TrackPropertyExpensesResponse)
	err := c.cc.Invoke(ctx, "/PropertyAccountingService/TrackPropertyExpenses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *propertyAccountingServiceClient) GeneratePropertyFinancialStatements(ctx context.Context, in *GeneratePropertyFinancialStatementsRequest, opts ...grpc.CallOption) (*GeneratePropertyFinancialStatementsResponse, error) {
	out := new(GeneratePropertyFinancialStatementsResponse)
	err := c.cc.Invoke(ctx, "/PropertyAccountingService/GeneratePropertyFinancialStatements", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *propertyAccountingServiceClient) GetPropertyFinancialReport(ctx context.Context, in *GetPropertyFinancialReportRequest, opts ...grpc.CallOption) (*GetPropertyFinancialReportResponse, error) {
	out := new(GetPropertyFinancialReportResponse)
	err := c.cc.Invoke(ctx, "/PropertyAccountingService/GetPropertyFinancialReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PropertyAccountingServiceServer is the server API for PropertyAccountingService service.
// All implementations must embed UnimplementedPropertyAccountingServiceServer
// for forward compatibility
type PropertyAccountingServiceServer interface {
	TrackPropertyRentalIncome(context.Context, *TrackPropertyRentalIncomeRequest) (*TrackPropertyRentalIncomeResponse, error)
	TrackPropertiesRentalIncome(context.Context, *TrackPropertiesRentalIncomeRequest) (*TrackPropertiesRentalIncomeResponse, error)
	TrackPropertyExpenses(context.Context, *TrackPropertyExpensesRequest) (*TrackPropertyExpensesResponse, error)
	GeneratePropertyFinancialStatements(context.Context, *GeneratePropertyFinancialStatementsRequest) (*GeneratePropertyFinancialStatementsResponse, error)
	GetPropertyFinancialReport(context.Context, *GetPropertyFinancialReportRequest) (*GetPropertyFinancialReportResponse, error)
	mustEmbedUnimplementedPropertyAccountingServiceServer()
}

// UnimplementedPropertyAccountingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPropertyAccountingServiceServer struct {
}

func (UnimplementedPropertyAccountingServiceServer) TrackPropertyRentalIncome(context.Context, *TrackPropertyRentalIncomeRequest) (*TrackPropertyRentalIncomeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrackPropertyRentalIncome not implemented")
}
func (UnimplementedPropertyAccountingServiceServer) TrackPropertiesRentalIncome(context.Context, *TrackPropertiesRentalIncomeRequest) (*TrackPropertiesRentalIncomeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrackPropertiesRentalIncome not implemented")
}
func (UnimplementedPropertyAccountingServiceServer) TrackPropertyExpenses(context.Context, *TrackPropertyExpensesRequest) (*TrackPropertyExpensesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrackPropertyExpenses not implemented")
}
func (UnimplementedPropertyAccountingServiceServer) GeneratePropertyFinancialStatements(context.Context, *GeneratePropertyFinancialStatementsRequest) (*GeneratePropertyFinancialStatementsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeneratePropertyFinancialStatements not implemented")
}
func (UnimplementedPropertyAccountingServiceServer) GetPropertyFinancialReport(context.Context, *GetPropertyFinancialReportRequest) (*GetPropertyFinancialReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPropertyFinancialReport not implemented")
}
func (UnimplementedPropertyAccountingServiceServer) mustEmbedUnimplementedPropertyAccountingServiceServer() {
}

// UnsafePropertyAccountingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PropertyAccountingServiceServer will
// result in compilation errors.
type UnsafePropertyAccountingServiceServer interface {
	mustEmbedUnimplementedPropertyAccountingServiceServer()
}

func RegisterPropertyAccountingServiceServer(s grpc.ServiceRegistrar, srv PropertyAccountingServiceServer) {
	s.RegisterService(&PropertyAccountingService_ServiceDesc, srv)
}

func _PropertyAccountingService_TrackPropertyRentalIncome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackPropertyRentalIncomeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PropertyAccountingServiceServer).TrackPropertyRentalIncome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PropertyAccountingService/TrackPropertyRentalIncome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PropertyAccountingServiceServer).TrackPropertyRentalIncome(ctx, req.(*TrackPropertyRentalIncomeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PropertyAccountingService_TrackPropertiesRentalIncome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackPropertiesRentalIncomeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PropertyAccountingServiceServer).TrackPropertiesRentalIncome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PropertyAccountingService/TrackPropertiesRentalIncome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PropertyAccountingServiceServer).TrackPropertiesRentalIncome(ctx, req.(*TrackPropertiesRentalIncomeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PropertyAccountingService_TrackPropertyExpenses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackPropertyExpensesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PropertyAccountingServiceServer).TrackPropertyExpenses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PropertyAccountingService/TrackPropertyExpenses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PropertyAccountingServiceServer).TrackPropertyExpenses(ctx, req.(*TrackPropertyExpensesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PropertyAccountingService_GeneratePropertyFinancialStatements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneratePropertyFinancialStatementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PropertyAccountingServiceServer).GeneratePropertyFinancialStatements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PropertyAccountingService/GeneratePropertyFinancialStatements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PropertyAccountingServiceServer).GeneratePropertyFinancialStatements(ctx, req.(*GeneratePropertyFinancialStatementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PropertyAccountingService_GetPropertyFinancialReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPropertyFinancialReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PropertyAccountingServiceServer).GetPropertyFinancialReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PropertyAccountingService/GetPropertyFinancialReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PropertyAccountingServiceServer).GetPropertyFinancialReport(ctx, req.(*GetPropertyFinancialReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PropertyAccountingService_ServiceDesc is the grpc.ServiceDesc for PropertyAccountingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PropertyAccountingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PropertyAccountingService",
	HandlerType: (*PropertyAccountingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TrackPropertyRentalIncome",
			Handler:    _PropertyAccountingService_TrackPropertyRentalIncome_Handler,
		},
		{
			MethodName: "TrackPropertiesRentalIncome",
			Handler:    _PropertyAccountingService_TrackPropertiesRentalIncome_Handler,
		},
		{
			MethodName: "TrackPropertyExpenses",
			Handler:    _PropertyAccountingService_TrackPropertyExpenses_Handler,
		},
		{
			MethodName: "GeneratePropertyFinancialStatements",
			Handler:    _PropertyAccountingService_GeneratePropertyFinancialStatements_Handler,
		},
		{
			MethodName: "GetPropertyFinancialReport",
			Handler:    _PropertyAccountingService_GetPropertyFinancialReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// ReportingServiceClient is the client API for ReportingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReportingServiceClient interface {
}

type reportingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReportingServiceClient(cc grpc.ClientConnInterface) ReportingServiceClient {
	return &reportingServiceClient{cc}
}

// ReportingServiceServer is the server API for ReportingService service.
// All implementations must embed UnimplementedReportingServiceServer
// for forward compatibility
type ReportingServiceServer interface {
	mustEmbedUnimplementedReportingServiceServer()
}

// UnimplementedReportingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedReportingServiceServer struct {
}

func (UnimplementedReportingServiceServer) mustEmbedUnimplementedReportingServiceServer() {}

// UnsafeReportingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportingServiceServer will
// result in compilation errors.
type UnsafeReportingServiceServer interface {
	mustEmbedUnimplementedReportingServiceServer()
}

func RegisterReportingServiceServer(s grpc.ServiceRegistrar, srv ReportingServiceServer) {
	s.RegisterService(&ReportingService_ServiceDesc, srv)
}

// ReportingService_ServiceDesc is the grpc.ServiceDesc for ReportingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReportingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ReportingService",
	HandlerType: (*ReportingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "properman.proto",
}

// BillingServiceClient is the client API for BillingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BillingServiceClient interface {
}

type billingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBillingServiceClient(cc grpc.ClientConnInterface) BillingServiceClient {
	return &billingServiceClient{cc}
}

// BillingServiceServer is the server API for BillingService service.
// All implementations must embed UnimplementedBillingServiceServer
// for forward compatibility
type BillingServiceServer interface {
	mustEmbedUnimplementedBillingServiceServer()
}

// UnimplementedBillingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBillingServiceServer struct {
}

func (UnimplementedBillingServiceServer) mustEmbedUnimplementedBillingServiceServer() {}

// UnsafeBillingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BillingServiceServer will
// result in compilation errors.
type UnsafeBillingServiceServer interface {
	mustEmbedUnimplementedBillingServiceServer()
}

func RegisterBillingServiceServer(s grpc.ServiceRegistrar, srv BillingServiceServer) {
	s.RegisterService(&BillingService_ServiceDesc, srv)
}

// BillingService_ServiceDesc is the grpc.ServiceDesc for BillingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BillingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "BillingService",
	HandlerType: (*BillingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "properman.proto",
}

// RentalAccountingServiceClient is the client API for RentalAccountingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RentalAccountingServiceClient interface {
	TrackRentalIncome(ctx context.Context, in *RentalIncomeRequest, opts ...grpc.CallOption) (*RentalIncomeResponse, error)
}

type rentalAccountingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRentalAccountingServiceClient(cc grpc.ClientConnInterface) RentalAccountingServiceClient {
	return &rentalAccountingServiceClient{cc}
}

func (c *rentalAccountingServiceClient) TrackRentalIncome(ctx context.Context, in *RentalIncomeRequest, opts ...grpc.CallOption) (*RentalIncomeResponse, error) {
	out := new(RentalIncomeResponse)
	err := c.cc.Invoke(ctx, "/RentalAccountingService/TrackRentalIncome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RentalAccountingServiceServer is the server API for RentalAccountingService service.
// All implementations must embed UnimplementedRentalAccountingServiceServer
// for forward compatibility
type RentalAccountingServiceServer interface {
	TrackRentalIncome(context.Context, *RentalIncomeRequest) (*RentalIncomeResponse, error)
	mustEmbedUnimplementedRentalAccountingServiceServer()
}

// UnimplementedRentalAccountingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRentalAccountingServiceServer struct {
}

func (UnimplementedRentalAccountingServiceServer) TrackRentalIncome(context.Context, *RentalIncomeRequest) (*RentalIncomeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrackRentalIncome not implemented")
}
func (UnimplementedRentalAccountingServiceServer) mustEmbedUnimplementedRentalAccountingServiceServer() {
}

// UnsafeRentalAccountingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RentalAccountingServiceServer will
// result in compilation errors.
type UnsafeRentalAccountingServiceServer interface {
	mustEmbedUnimplementedRentalAccountingServiceServer()
}

func RegisterRentalAccountingServiceServer(s grpc.ServiceRegistrar, srv RentalAccountingServiceServer) {
	s.RegisterService(&RentalAccountingService_ServiceDesc, srv)
}

func _RentalAccountingService_TrackRentalIncome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RentalIncomeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RentalAccountingServiceServer).TrackRentalIncome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/RentalAccountingService/TrackRentalIncome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RentalAccountingServiceServer).TrackRentalIncome(ctx, req.(*RentalIncomeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RentalAccountingService_ServiceDesc is the grpc.ServiceDesc for RentalAccountingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RentalAccountingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "RentalAccountingService",
	HandlerType: (*RentalAccountingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TrackRentalIncome",
			Handler:    _RentalAccountingService_TrackRentalIncome_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "properman.proto",
}

// PropertyMaintenanceServiceClient is the client API for PropertyMaintenanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PropertyMaintenanceServiceClient interface {
}

type propertyMaintenanceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPropertyMaintenanceServiceClient(cc grpc.ClientConnInterface) PropertyMaintenanceServiceClient {
	return &propertyMaintenanceServiceClient{cc}
}

// PropertyMaintenanceServiceServer is the server API for PropertyMaintenanceService service.
// All implementations must embed UnimplementedPropertyMaintenanceServiceServer
// for forward compatibility
type PropertyMaintenanceServiceServer interface {
	mustEmbedUnimplementedPropertyMaintenanceServiceServer()
}

// UnimplementedPropertyMaintenanceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPropertyMaintenanceServiceServer struct {
}

func (UnimplementedPropertyMaintenanceServiceServer) mustEmbedUnimplementedPropertyMaintenanceServiceServer() {
}

// UnsafePropertyMaintenanceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PropertyMaintenanceServiceServer will
// result in compilation errors.
type UnsafePropertyMaintenanceServiceServer interface {
	mustEmbedUnimplementedPropertyMaintenanceServiceServer()
}

func RegisterPropertyMaintenanceServiceServer(s grpc.ServiceRegistrar, srv PropertyMaintenanceServiceServer) {
	s.RegisterService(&PropertyMaintenanceService_ServiceDesc, srv)
}

// PropertyMaintenanceService_ServiceDesc is the grpc.ServiceDesc for PropertyMaintenanceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PropertyMaintenanceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PropertyMaintenanceService",
	HandlerType: (*PropertyMaintenanceServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "properman.proto",
}
